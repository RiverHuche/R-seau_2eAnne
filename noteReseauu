Notes Réseau : 

NAt : Network address Translation 

192.168.1.1 : on évolue dans des réseaux privés.

réseau  privé : réseau sur lequel les adresses ne sont pas routables à l'extérieur.

dans un protocole ip on a des ip réservées : 10.0.0.0/8, 172.16.0.0/12 et 192.168.0.0

Possible grâce au NAT : 


Le routeur, connecté à la fois au réseau privé et à l'extérieur, se charge de faire correspondre
les adresses IP privées avec des adresses IP publiques


Ce routeur maintient une table d'associa-
tion entre ces adresses. Lorsqu'un paquet provenant d'une machine du réseau privé et destiné à
une machine externe arrive sur le routeur, celui-ci modie l'adresse source, en la remplaçant par
l'adresse publique. Lorsque la réponse arrive, il fera l'opération inverse.

ping : regarde sa table de routage

NAT : Interface entre adresses privées et publiques (on le met sur R1 dans TP1)

On commence tout d'abord par dénir un pool d'adresses publiques qui seront utilisées pour
remplacer les adresses privées, lorsque les machines du réseau lana souhaiteront communi-
quer avec l'extérieur. On choisit la plage d'adresses
conf term
ip nat pool lana 64.64.64.65 64.64.64.126 netmask 255.255.255.192

On crée une ACL (Access Control List, comme lors du TP sur le pare-feu) identiant les
adresses qui doivent être transposées
access - l i s t 1 permit 192.168.0.0 0.0.0.255
Ici les adresses du réseau 192.168.0.0/24 seront traduites
3. Lier l'ACL au pool d'adresses
ip nat inside source l i s t 1 pool lana


Le NAT permet a la machine de ne pas être dispoé publiquement au reste du réseau (on vous voit pas) donc sécurité top.

La conguration que nous venons de faire, traduit un ensemble d'adresses privées, vers un en-
semble d'adresses publiques. Que faire si vous ne disposez que d'une seule adresse publique ?
L'utilisation d'une table d'association entre les adresses privées et les adresses publiques n'est donc
plus possible. Comment distinguer les réponses, s'il n'y a plus qu'une seule adresse publique ?
Le PAT va utiliser les numéros de port



On souhaite repartir sur un routeur sans la conguration précédente. Reprendre la copie du
projet sauvegardé précédemment.
2.2 Nous allons mettre en place le NAT/PAT sur le routeur 1
1. On crée une ACL identiant les adresses qui doivent être transposées
conf term
access - l i s t 1 permit 192.168.0.0 0.0.0.255
Ici les adresses du réseau 192.168.0.0/24 seront traduites
2. l'ACL est liée à l'adresse publique
ip nat inside source l i s t 1 interface e0 /1 overload
 Les adresses privées sont celles dénies par l'ACL
 L'adresse publique est celle associée à l'interface e0/1
 Le mot clé overload spécie que les numéros de port seront utilisés pour gérer les
traductions
3. On dénit l'interface reliée au réseau privé
interface e0 /0
ip nat inside
exit
4. On dénit l'interface reliée au réseau public
interface e0 /1
ip nat outside
end


Réseau privé : réseau pas sensé être connu du monde extérieur

NAT : accéder à l'extérieur depuis un réseau privé, les adresses ip des paquets qui sortent, ont tous la même ip publique

dans table d'association (TP1) on aura portsource, ip privé qui sera associé à nouveau port source : PAT

NAT : avantages : nos machines sont invisibles depuis l'extérieur, résolu le problème des ipv4, on peut avoir les même ip

Les deux VLAN arrivent ils à communiquer ? Pourquoi ? Il n'y'a pas de passerelle

Le switch qui recoit le premier message depuis un VLAN modifie alors avec dot1Q la tram ethernet et y met l'id de la VLAN.
Cettre trame ethernet est modifiée seulement entre les liaisons des switch.


e0/0.10 = interface VLAN10  interface VLAN20 = e0/0.20 

socket = utiliser la couche transport, chaque pc ouvre une socket, et les pc communiquent avec les socket (dans n'importe quelle langage)

"0.0.0.0" car ça publiera la socket sur toutes les interfaces disponible de notre machine.

BUFSIZE : ste de donnée maximale à recevoir.

sock.bind() : associe la socket a l'ip et un port
client initie l'échange, donc on a pas besoin de son bind, on s'en fiche qu'il soit connue
client a pas de listen car il envoie juste

sock.recvfrom(BUFSIZE) = couple data et addresse (addresse du port de celui qui nous contacte)

sock.setsockopt() permet de réutiliser une socket sur une adresse qui a déjà ete

sock.listen(int) va activer le serveur socket pour accepter des connexions = ce sera une socket qui se ra destinée à accueillir des connexions
typique d'un Serveur et non d'un client, int spécifie le nombre de connexions qu'elle peut accepter (au bout de int dmd de connexions, on met en attente)

sock.accept() : permet d'accepter une nouvelle connexion, = méthode bloquante, on attend d'une connexion qui arrive


socket() = type par défaut c'est SOCK_STREAM = TCP : flux virtuel entre deux pc qui utilisent 

indispensable pour un serveur d'avoir un bind, le client est jamais contacté directment, en gros le bind est pas obligatoire

makefile() = 

le syn ack se fait au moment du socket.connect du client car il est lié au socket.accept() du serveur

une fois que le flux est établie (que le sockets communiquent), le client et serveur sont au même niveau et la connexion fonctionne de la même manière

Connexions Internet actives (sans serveurs)
Proto Recv-Q Send-Q Adresse locale          Adresse distante        Etat      
tcp        0      0 or-iut-i201-f20.i:55820 24.224.186.35.bc.:https TIME_WAIT  
tcp        0      0 or-iut-i201-f20.i:49644 172.64.148.197:https    ESTABLISHED
tcp        0      0 or-iut-i201-f20.i:36896 13.107.246.42:https     TIME_WAIT  
tcp        0      0 or-iut-i201-f20.i:53170 proxima.iut45.univ-:nfs TIME_WAIT  
tcp        0      0 or-iut-i201-f20.i:40794 or-iut-srv-ad1.iut:ldap ESTABLISHED
tcp        0      0 or-iut-i201-f20.i:54320 93.243.107.34.bc.:https ESTABLISHED
tcp        0      0 or-iut-i201-f20.i:49670 172.64.148.197:https    ESTABLISHED
tcp        0      0 or-iut-i201-f20.i:32952 162.159.140.229:https   ESTABLISHED
tcp        0      0 or-iut-i201-f20.i:33828 151.101.0.223:https     ESTABLISHED
tcp        0      0 or-iut-i201-f20.i:45324 13.107.5.93:https       TIME_WAIT  
tcp        0      0 or-iut-i201-f20.i:35634 77.95.65.78:https       TIME_WAIT  
tcp        0      0 or-iut-i201-f20.iut:841 proxima.iut45.univ-:nfs TIME_WAIT  
tcp        0      0 or-iut-i201-f20.iut:758 proxima.iut45.univ-:nfs TIME_WAIT  
tcp        0      0 or-iut-i201-f20.i:53740 par10s42-in-f3.1e:https ESTABLISHED

netstat -uap (u pour udp, voir TP5)

udp        0      0 0.0.0.0:5556            0.0.0.0:*                           86388/python3  (86388 = pid)

tcp        0      0 0.0.0.0:freeciv         0.0.0.0:*               LISTEN      90946/python3       
tcp        0      0 localhost:57680         localhost:freeciv       ESTABLISHED 90973/python3       
tcp        0      0 localhost:freeciv       localhost:57680         ESTABLISHED 90946/python3 

= LISTEN = socket en mode écoute soit la socketserveur, ESTABLISHED = les socket de la connexion, celle du milieu c'est le serveur car freeciv

non possédés ne seront pas affichées, vous devez être root pour les voir toutes.)
tcp        0      0 0.0.0.0:5557            0.0.0.0:*               LISTEN      92140/python3       
tcp        0      0 or-iut-i201-f20.iu:5557 or-iut-i201-f21.i:58240 ESTABLISHED 92140/python3       
tcp        1      0 localhost:36016         localhost:freeciv       CLOSE_WAIT  91537/python3 

(jétais le serveur et hugo le client).

getattr (regarder)
